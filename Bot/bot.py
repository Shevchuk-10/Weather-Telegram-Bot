import os
import json
import logging
import aiohttp
import asyncio
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
from telegram import Update, KeyboardButton, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from dotenv import load_dotenv



# Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ
load_dotenv()

# ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ
WEATHER_API_KEY = os.getenv("WEATHER_API_KEY")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
DJANGO_API_URL = "http://127.0.0.1:8000/api/subscribe/"

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
logging.basicConfig(format="%(asctime)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)

async def fetch_weather_data(url: str) -> dict:
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                response.raise_for_status()
                return await response.json()
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¾ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ğµ: {e}")
        return {}


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [
        [KeyboardButton("ğŸ“ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ³ĞµĞ¾Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ", request_location=True)],
        [KeyboardButton("âœ Ğ’Ğ²ĞµÑÑ‚Ğ¸ Ğ³Ğ¾Ñ€Ğ¾Ğ´ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ")],
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
    await update.message.reply_text("ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ¯ Ğ±Ğ¾Ñ‚ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ñ‹. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ, ĞºĞ°Ğº Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ñƒ:",
                                    reply_markup=reply_markup)


async def get_weather_by_location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_location = update.message.location
    latitude = user_location.latitude
    longitude = user_location.longitude
    user_id = update.message.chat_id

    url = f"http://api.openweathermap.org/data/2.5/weather?lat={latitude}&lon={longitude}&appid={WEATHER_API_KEY}&units=metric&lang=ru"
    data = await fetch_weather_data(url)

    if not data or data.get("cod") != 200:
        await update.message.reply_text("âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ñƒ Ğ´Ğ»Ñ Ğ²Ğ°ÑˆĞµĞ¹ Ğ³ĞµĞ¾Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°.")
        return

    weather_message = format_weather_message(data)

    keyboard = [[InlineKeyboardButton("ğŸ”” ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ",
                                      callback_data=f"subscribe_location_{latitude}_{longitude}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(weather_message, reply_markup=reply_markup)


async def get_weather_by_city(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    city_name = update.message.text.strip()
    if city_name.lower() in ["Ğ²Ğ²ĞµÑÑ‚Ğ¸ Ğ³Ğ¾Ñ€Ğ¾Ğ´ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ", "âœ Ğ²Ğ²ĞµÑÑ‚Ğ¸ Ğ³Ğ¾Ñ€Ğ¾Ğ´ Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ"]:
        await update.message.reply_text("âœ ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ° Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ:")
        return

    url = f"http://api.openweathermap.org/data/2.5/weather?q={city_name}&appid={WEATHER_API_KEY}&units=metric&lang=ru"
    data = await fetch_weather_data(url)

    if not data or data.get("cod") != 200:
        await update.message.reply_text("âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ñƒ Ğ´Ğ»Ñ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°.")
        return

    weather_message = format_weather_message(data)
    keyboard = [[InlineKeyboardButton("ğŸ”” ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ", callback_data=f"subscribe_city_{city_name}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(weather_message, reply_markup=reply_markup)


async def subscribe(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    data = query.data.split("_")
    user_id = query.message.chat.id

    if data[1] == "city":
        city_name = "_".join(data[2:])
        payload = {"user_id": user_id, "city": city_name}
    else:
        latitude, longitude = data[2], data[3]
        payload = {"user_id": user_id, "latitude": latitude, "longitude": longitude}

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(DJANGO_API_URL, json=payload) as response:
                response.raise_for_status()
        await query.edit_message_text("âœ… Ğ’Ñ‹ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ°Ğ»Ğ¸ÑÑŒ Ğ½Ğ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ğµ!")
    except Exception as e:
        await query.edit_message_text("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞµ. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.")
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞµ: {e}")


def format_weather_message(data: dict) -> str:
    city_name = data.get("name", "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾Ğµ Ğ¼ĞµÑÑ‚Ğ¾")
    temperature = data["main"]["temp"]
    feels_like = data["main"]["feels_like"]
    description = data["weather"][0]["description"]
    humidity = data["main"]["humidity"]
    wind_speed = data["wind"]["speed"]

    return (
        f"ğŸŒ ĞŸĞ¾Ğ³Ğ¾Ğ´Ğ° Ğ² {city_name}:\n"
        f"ğŸŒ¡ Ğ¢ĞµĞ¼Ğ¿ĞµÑ€Ğ°Ñ‚ÑƒÑ€Ğ°: {temperature}Â°C\n"
        f"ğŸ¤” ĞÑ‰ÑƒÑ‰Ğ°ĞµÑ‚ÑÑ ĞºĞ°Ğº: {feels_like}Â°C\n"
        f"ğŸ“œ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: {description.capitalize()}\n"
        f"ğŸ’§ Ğ’Ğ»Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: {humidity}%\n"
        f"ğŸ’¨ Ğ¡ĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ Ğ²ĞµÑ‚Ñ€Ğ°: {wind_speed} Ğ¼/Ñ"
    )


def run_telegram_bot():
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.LOCATION, get_weather_by_location))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, get_weather_by_city))
    app.add_handler(CallbackQueryHandler(subscribe))

    logger.info("Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½...")
    app.run_polling()


if __name__ == "__main__":
    run_telegram_bot()
